package email

import (
	"bytes"
	"errors"
	"html/template"
	"strings"
	"time"

	"morningweave/internal/dedupe"
)

const (
	DefaultWordCap  = 320
	DefaultMaxItems = 10
)

var ErrNoItems = errors.New("no items to render")

type RenderOptions struct {
	Title       string
	WordCap     int
	MaxItems    int
	GeneratedAt time.Time
}

type RenderResult struct {
	HTML      string
	Items     int
	Words     int
	Truncated bool
}

type templateData struct {
	Title       string
	GeneratedAt string
	Items       []templateItem
	Truncated   bool
}

type templateItem struct {
	Title      string
	PrimaryURL string
	Excerpt    string
	Sources    []templateSource
}

type templateSource struct {
	Platform string
	URL      string
	Label    string
}

const digestTemplate = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{.Title}}</title>
  <style>
    body { margin: 0; padding: 0; background: #f6f6f6; color: #1a1a1a; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; }
    .container { max-width: 640px; margin: 0 auto; background: #ffffff; padding: 24px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .meta { font-size: 12px; color: #777; margin-bottom: 16px; }
    .item { padding: 16px 0; border-top: 1px solid #eee; }
    .item:first-child { border-top: 0; }
    .item-title { font-size: 16px; margin: 0 0 6px; }
    .item-title a { color: #111; text-decoration: none; }
    .excerpt { margin: 0 0 8px; color: #444; line-height: 1.4; }
    .sources { font-size: 12px; color: #666; }
    .badge { display: inline-block; background: #f2f2f2; color: #444; padding: 2px 6px; margin-right: 6px; border-radius: 12px; font-size: 11px; }
    .sources a { color: #444; text-decoration: none; margin-right: 10px; }
    .footer { font-size: 12px; color: #888; margin-top: 20px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>{{.Title}}</h1>
    {{if .GeneratedAt}}<div class="meta">{{.GeneratedAt}}</div>{{end}}
    {{range .Items}}
      <div class="item">
        <div class="item-title"><a href="{{.PrimaryURL}}">{{.Title}}</a></div>
        {{if .Excerpt}}<p class="excerpt">{{.Excerpt}}</p>{{end}}
        <div class="sources">
          {{range .Sources}}
            <span class="badge">{{.Platform}}</span><a href="{{.URL}}">{{.Label}}</a>
          {{end}}
        </div>
      </div>
    {{end}}
    {{if .Truncated}}<div class="footer">Digest truncated to fit word cap.</div>{{else}}<div class="footer">Generated by MorningWeave.</div>{{end}}
  </div>
</body>
</html>`

func RenderDigest(items []dedupe.MergedItem, opts RenderOptions) (RenderResult, error) {
	var result RenderResult

	maxItems := opts.MaxItems
	if maxItems <= 0 {
		maxItems = DefaultMaxItems
	}
	wordCap := opts.WordCap
	if wordCap <= 0 {
		wordCap = DefaultWordCap
	}

	title := strings.TrimSpace(opts.Title)
	if title == "" {
		title = "MorningWeave Digest"
	}

	remaining := wordCap
	for _, item := range items {
		if result.Items >= maxItems {
			break
		}
		itemTitle := strings.TrimSpace(item.Item.Title)
		if itemTitle == "" {
			continue
		}
		titleWords := countWords(itemTitle)
		if titleWords == 0 || titleWords > remaining {
			break
		}
		remaining -= titleWords

		_, wordsUsed, truncated := buildExcerpt(item.Item.Text, remaining)
		remaining -= wordsUsed

		result.Words += titleWords + wordsUsed
		result.Items++
		result.Truncated = result.Truncated || truncated

		if truncated || remaining == 0 {
			break
		}
	}

	if result.Items == 0 {
		return RenderResult{}, ErrNoItems
	}

	dataItems := make([]templateItem, 0, result.Items)
	remaining = wordCap
	itemsUsed := 0
	for _, item := range items {
		if itemsUsed >= result.Items {
			break
		}
		itemTitle := strings.TrimSpace(item.Item.Title)
		if itemTitle == "" {
			continue
		}
		titleWords := countWords(itemTitle)
		if titleWords == 0 || titleWords > remaining {
			break
		}
		remaining -= titleWords

		excerpt, wordsUsed, _ := buildExcerpt(item.Item.Text, remaining)
		remaining -= wordsUsed

		dataItems = append(dataItems, templateItem{
			Title:      itemTitle,
			PrimaryURL: primaryURL(item),
			Excerpt:    excerpt,
			Sources:    buildSources(item),
		})
		itemsUsed++
		if remaining == 0 {
			break
		}
	}

	tmpl, err := template.New("digest").Parse(digestTemplate)
	if err != nil {
		return RenderResult{}, err
	}

	var buf bytes.Buffer
	data := templateData{
		Title:       title,
		Items:       dataItems,
		Truncated:   result.Truncated,
		GeneratedAt: formatGeneratedAt(opts.GeneratedAt),
	}
	if err := tmpl.Execute(&buf, data); err != nil {
		return RenderResult{}, err
	}
	result.HTML = buf.String()
	return result, nil
}

func buildExcerpt(text string, remaining int) (string, int, bool) {
	clean := normalizeSpaces(text)
	if clean == "" || remaining <= 0 {
		return "", 0, remaining <= 0
	}
	words := strings.Fields(clean)
	if len(words) <= remaining {
		return strings.Join(words, " "), len(words), false
	}
	return strings.Join(words[:remaining], " ") + "...", remaining, true
}

func normalizeSpaces(value string) string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return ""
	}
	fields := strings.Fields(trimmed)
	return strings.Join(fields, " ")
}

func countWords(value string) int {
	if strings.TrimSpace(value) == "" {
		return 0
	}
	return len(strings.Fields(value))
}

func buildSources(item dedupe.MergedItem) []templateSource {
	links := item.Sources
	if len(links) == 0 && item.Item.URL != "" {
		links = append(links, dedupe.SourceLink{Source: item.Item.Source, URL: item.Item.URL})
	}
	result := make([]templateSource, 0, len(links))
	for _, link := range links {
		label := sourceLabel(link)
		platform := platformLabel(link.Source.Platform)
		url := strings.TrimSpace(link.URL)
		if url == "" {
			continue
		}
		result = append(result, templateSource{
			Platform: platform,
			URL:      url,
			Label:    label,
		})
	}
	return result
}

func sourceLabel(link dedupe.SourceLink) string {
	if link.Source.SourceType != "" && link.Source.Identifier != "" {
		return link.Source.SourceType + ": " + link.Source.Identifier
	}
	if link.Source.Identifier != "" {
		return link.Source.Identifier
	}
	if link.Source.SourceType != "" {
		return link.Source.SourceType
	}
	if link.URL != "" {
		return "source"
	}
	return "source"
}

func platformLabel(platform string) string {
	trimmed := strings.TrimSpace(platform)
	lower := strings.ToLower(trimmed)
	switch lower {
	case "hn":
		return "Hacker News"
	case "x":
		return "X"
	case "reddit":
		return "Reddit"
	case "instagram":
		return "Instagram"
	case "":
		return "Source"
	default:
		if trimmed == "" {
			return "Source"
		}
		return strings.ToUpper(trimmed[:1]) + trimmed[1:]
	}
}

func primaryURL(item dedupe.MergedItem) string {
	if item.CanonicalURL != "" {
		return item.CanonicalURL
	}
	if item.Item.URL != "" {
		return item.Item.URL
	}
	for _, link := range item.Sources {
		if link.URL != "" {
			return link.URL
		}
	}
	return ""
}

func formatGeneratedAt(value time.Time) string {
	if value.IsZero() {
		return ""
	}
	return "Generated " + value.Local().Format("2006-01-02 15:04")
}
