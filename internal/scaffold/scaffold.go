package scaffold

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"morningweave/internal/storage"
)

const (
	DefaultConfigFilename   = "config.yaml"
	DefaultUserTodoFilename = "USER_TODO.md"
	DefaultEmailProvider    = "resend"
	DefaultStoragePath      = "data/morningweave.db"
)

var validEmailProviders = map[string]struct{}{
	"resend": {},
	"smtp":   {},
}

const configTemplate = `# MorningWeave configuration
# Generated by {{BACKTICK}}morningweave init{{BACKTICK}}.
version: 1

global:
  # default_schedule uses 5-field cron (min hour dom mon dow).
  default_schedule: "0 7 * * *"
  languages:
    - en
    - no
  digest:
    word_cap: 320
    max_items: 10

email:
  provider: "{{EMAIL_PROVIDER}}"
  from: "MorningWeave <you@example.com>"
  to:
    - "you@example.com"
  subject: "MorningWeave Digest - {{date}}"
  resend:
    api_key_ref: "keychain:resend"
  smtp:
    host: "smtp.example.com"
    port: 587
    username: "you@example.com"
    password_ref: "keychain:smtp"

# Plaintext secrets (fallback only). Prefer keychain/1Password for real usage.
# Use references like secrets:resend or env:RESEND_API_KEY in config fields.
secrets:
  values: {}

platforms:
  reddit:
    enabled: false
    weight: 1.0
    credentials_ref: "keychain:reddit"
    sources:
      subreddits:
        - "golang"
      users: []
      keywords: []
    # source_weights maps identifiers to weights per source type (optional).
    # Example:
    # source_weights:
    #   subreddits:
    #     golang: 1.2
    source_weights: {}
  x:
    enabled: false
    weight: 1.0
    credentials_ref: "keychain:x"
    sources:
      users: []
      keywords: []
      lists: []
    source_weights: {}
  instagram:
    enabled: false
    weight: 1.0
    credentials_ref: "keychain:instagram"
    sources:
      accounts: []
      hashtags: []
    source_weights: {}
  hn:
    enabled: true
    weight: 1.0
    sources:
      lists:
        - "top"
        - "best"
      keywords: []
    source_weights: {}

tags:
  - name: "ai"
    keywords:
      - "llm"
      - "machine learning"
    # schedule uses 5-field cron (min hour dom mon dow).
    schedule: "0 7 * * *"
    language:
      - "en"
    recipients:
      - "you@example.com"
    weight: 1.0

categories: []

logging:
  level: "info"
  retention_days: 30

storage:
  path: "data/morningweave.db"
  seen_retention_days: 45
`

const userTodoTemplate = `# MorningWeave USER_TODO

This file is auto-maintained by {{BACKTICK}}morningweave init{{BACKTICK}}.
Selected email provider: {{EMAIL_PROVIDER}}

## Email provider: Resend
- [ ] Create a Resend account and verify sender domain.
- [ ] Create a Resend API key.
- [ ] Store the key in the keychain or 1Password.
- [ ] Update config.yaml {{BACKTICK}}email.resend.api_key_ref{{BACKTICK}} to match the stored key reference.
- [ ] Run {{BACKTICK}}morningweave test-email{{BACKTICK}} once configured.

## Email provider: SMTP
- [ ] Collect SMTP host, port, username, and password.
- [ ] Store the SMTP password in the keychain or 1Password.
- [ ] Update config.yaml {{BACKTICK}}email.smtp{{BACKTICK}} settings and {{BACKTICK}}email.smtp.password_ref{{BACKTICK}}.
- [ ] Run {{BACKTICK}}morningweave test-email{{BACKTICK}} once configured.

## Reddit
- [ ] Create a Reddit app (script) at https://www.reddit.com/prefs/apps.
- [ ] Capture client id, client secret, and user agent.
- [ ] Required OAuth scopes: read.
- [ ] Store the secrets in the keychain or 1Password.
- [ ] Update config.yaml {{BACKTICK}}platforms.reddit.credentials_ref{{BACKTICK}}.

## X (x.com)
- [ ] Create an app in the X developer portal and note the tier limits.
- [ ] Generate the required API keys/tokens.
- [ ] Required scopes: tweet.read, users.read.
- [ ] Store the secrets in the keychain or 1Password.
- [ ] Update config.yaml {{BACKTICK}}platforms.x.credentials_ref{{BACKTICK}}.

## Instagram
- [ ] Ensure the Instagram account is Business or Creator and linked to a Facebook Page/app.
- [ ] Enable Instagram Graph API on the Facebook app and generate an access token.
- [ ] Required scopes: instagram_basic, pages_show_list, instagram_manage_insights.
- [ ] Store the token in the keychain or 1Password.
- [ ] Update config.yaml {{BACKTICK}}platforms.instagram.credentials_ref{{BACKTICK}}.

## Hacker News
- [ ] No API key required. Configure sources under {{BACKTICK}}platforms.hn.sources{{BACKTICK}}.

## Security
- [ ] Prefer keychain or 1Password for secrets; avoid plaintext YAML secrets.
- [ ] If you must use plaintext, store under {{BACKTICK}}secrets.values{{BACKTICK}} and reference via {{BACKTICK}}secrets:<key>{{BACKTICK}}.
`

type InitResult struct {
	Created []string
	Skipped []string
}

func NormalizeEmailProvider(value string) string {
	candidate := strings.TrimSpace(strings.ToLower(value))
	if candidate == "" {
		return DefaultEmailProvider
	}
	if _, ok := validEmailProviders[candidate]; ok {
		return candidate
	}
	return DefaultEmailProvider
}

func ValidEmailProviders() []string {
	return []string{"resend", "smtp"}
}

func DefaultConfigYAML(emailProvider string) string {
	provider := NormalizeEmailProvider(emailProvider)
	output := strings.ReplaceAll(configTemplate, "{{EMAIL_PROVIDER}}", provider)
	return strings.ReplaceAll(output, "{{BACKTICK}}", "`")
}

func DefaultUserTodo(emailProvider string) string {
	provider := NormalizeEmailProvider(emailProvider)
	output := strings.ReplaceAll(userTodoTemplate, "{{EMAIL_PROVIDER}}", provider)
	return strings.ReplaceAll(output, "{{BACKTICK}}", "`")
}

func InitWorkspace(configPath string, emailProvider string, overwrite bool) (InitResult, error) {
	provider := NormalizeEmailProvider(emailProvider)
	todoPath := filepath.Join(filepath.Dir(configPath), DefaultUserTodoFilename)

	result := InitResult{}

	created, err := writeFile(configPath, DefaultConfigYAML(provider), overwrite)
	if err != nil {
		return result, err
	}
	if created {
		result.Created = append(result.Created, configPath)
	} else {
		result.Skipped = append(result.Skipped, configPath)
	}

	created, err = writeFile(todoPath, DefaultUserTodo(provider), overwrite)
	if err != nil {
		return result, err
	}
	if created {
		result.Created = append(result.Created, todoPath)
	} else {
		result.Skipped = append(result.Skipped, todoPath)
	}

	dbPath := filepath.Join(filepath.Dir(configPath), DefaultStoragePath)
	dbCreated, err := storage.EnsureDatabase(dbPath)
	if err != nil {
		return result, err
	}
	if dbCreated {
		result.Created = append(result.Created, dbPath)
	} else {
		result.Skipped = append(result.Skipped, dbPath)
	}

	return result, nil
}

func writeFile(path string, content string, overwrite bool) (bool, error) {
	if !overwrite {
		if _, err := os.Stat(path); err == nil {
			return false, nil
		} else if !os.IsNotExist(err) {
			return false, fmt.Errorf("failed to stat %s: %w", path, err)
		}
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return false, fmt.Errorf("failed to create directories for %s: %w", path, err)
	}

	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return false, fmt.Errorf("failed to write %s: %w", path, err)
	}

	return true, nil
}
