package scaffold

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"morningweave/internal/storage"
)

const (
	DefaultConfigFilename = "config.yaml"
	DefaultEmailProvider  = "resend"
	DefaultStoragePath    = "data/morningweave.db"
)

var validEmailProviders = map[string]struct{}{
	"resend": {},
	"smtp":   {},
}

const configTemplate = `# MorningWeave configuration
# Generated by {{BACKTICK}}morningweave init{{BACKTICK}}.
version: 1

global:
  # default_schedule uses 5-field cron (min hour dom mon dow).
  default_schedule: "0 7 * * *"
  languages:
    - en
    - no
  digest:
    word_cap: 320
    max_items: 10

email:
  provider: "{{EMAIL_PROVIDER}}"
  from: "MorningWeave <you@example.com>"
  to:
    - "you@example.com"
  subject: "MorningWeave Digest - {{date}}"
  resend:
    api_key_ref: "keychain:resend"
  smtp:
    host: "smtp.example.com"
    port: 587
    username: "you@example.com"
    password_ref: "keychain:smtp"

# Plaintext secrets (fallback only). Prefer keychain/1Password for real usage.
# Use references like secrets:resend or env:RESEND_API_KEY in config fields.
secrets:
  values: {}

platforms:
  reddit:
    enabled: false
    weight: 1.0
    credentials_ref: "keychain:reddit"
    sources:
      subreddits:
        - "golang"
      users: []
      keywords: []
    # source_weights maps identifiers to weights per source type (optional).
    # Example:
    # source_weights:
    #   subreddits:
    #     golang: 1.2
    source_weights: {}
  x:
    enabled: false
    weight: 1.0
    credentials_ref: "keychain:x"
    sources:
      users: []
      keywords: []
      lists: []
    source_weights: {}
  instagram:
    enabled: false
    weight: 1.0
    credentials_ref: "keychain:instagram"
    sources:
      accounts: []
      hashtags: []
    source_weights: {}
  hn:
    enabled: true
    weight: 1.0
    sources:
      lists:
        - "top"
        - "best"
      keywords: []
    source_weights: {}

tags:
  - name: "ai"
    keywords:
      - "llm"
      - "machine learning"
    # schedule uses 5-field cron (min hour dom mon dow).
    schedule: "0 7 * * *"
    language:
      - "en"
    recipients:
      - "you@example.com"
    weight: 1.0

categories: []

logging:
  level: "info"
  retention_days: 30

storage:
  path: "data/morningweave.db"
  seen_retention_days: 45
`

type InitResult struct {
	Created []string
	Skipped []string
}

func NormalizeEmailProvider(value string) string {
	candidate := strings.TrimSpace(strings.ToLower(value))
	if candidate == "" {
		return DefaultEmailProvider
	}
	if _, ok := validEmailProviders[candidate]; ok {
		return candidate
	}
	return DefaultEmailProvider
}

func ValidEmailProviders() []string {
	return []string{"resend", "smtp"}
}

func DefaultConfigYAML(emailProvider string) string {
	provider := NormalizeEmailProvider(emailProvider)
	output := strings.ReplaceAll(configTemplate, "{{EMAIL_PROVIDER}}", provider)
	return strings.ReplaceAll(output, "{{BACKTICK}}", "`")
}

func InitWorkspace(configPath string, emailProvider string, overwrite bool) (InitResult, error) {
	provider := NormalizeEmailProvider(emailProvider)

	result := InitResult{}

	created, err := writeFile(configPath, DefaultConfigYAML(provider), overwrite)
	if err != nil {
		return result, err
	}
	if created {
		result.Created = append(result.Created, configPath)
	} else {
		result.Skipped = append(result.Skipped, configPath)
	}

	dbPath := filepath.Join(filepath.Dir(configPath), DefaultStoragePath)
	dbCreated, err := storage.EnsureDatabase(dbPath)
	if err != nil {
		return result, err
	}
	if dbCreated {
		result.Created = append(result.Created, dbPath)
	} else {
		result.Skipped = append(result.Skipped, dbPath)
	}

	return result, nil
}

func writeFile(path string, content string, overwrite bool) (bool, error) {
	if !overwrite {
		if _, err := os.Stat(path); err == nil {
			return false, nil
		} else if !os.IsNotExist(err) {
			return false, fmt.Errorf("failed to stat %s: %w", path, err)
		}
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return false, fmt.Errorf("failed to create directories for %s: %w", path, err)
	}

	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return false, fmt.Errorf("failed to write %s: %w", path, err)
	}

	return true, nil
}
